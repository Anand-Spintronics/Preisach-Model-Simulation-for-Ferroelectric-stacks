# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-hAguC0o1LWJVO04RZTT4hltEo8LeQAg
"""

# Code to simulate the Preisach Model: Here We have used Fslove to solve these questions in self-consistent manner
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams

from scipy.optimize import fsolve
from matplotlib.ticker import LogLocator

epsil_0 = 8.85e-12

ts = 2e-9  # metal 1 thickness or source
td = 2e-9  # metal 2 thickness or drain

epsil_1 = 3
epsil_2 = 3
lambda1 = 0.5e-10
lambda2 = 0.5e-10

Ef_1 = 0
Ef_2 = 0
t_fe = 5e-9

epsil_fe = 25
t_il1 = 1e-9
t_il2 = 1e-9
t_il3 = 1e-9
t_il4 = 1e-9

t_fi1 = t_fe + t_il1
t_fi2 = t_fe + t_il1 + t_il2
t_fi3 = t_fe + t_il1 + t_il2 + t_il3
t_fi4 = t_fe + t_il1 + t_il2 + t_il3 + t_il4

epsil_il1 = 25
epsil_il2 = 25
epsil_il3 = 25
epsil_il4 = 25

# Band Discontinuities
phi_1 = 1.5
phi_2 = 0.55
phi_c1 = 1.5
phi_c2 = 0.55
phi_c3 = 1.5
phi_c4 = 0.55

v_in = np.linspace(-3,3, 100)      # Input Voltage

p_s = 0.13             # sat. pol in C/m2
p_r = 0.12*0.5                  # remanant pol in C/m2
V_c = 0.4          # coercive voltage in V
V_bi=0
print(f"P_s = {p_s:.4f}\t P_r = {p_r:.4f} \t V_c = {V_c:.4f}")
Parameter1=t_fe/(epsil_0*epsil_fe)
Parameter2=t_fe/(epsil_fe)
Parameter3=(1.0/(2*V_c))*np.log((p_s+p_r)/(p_s-p_r))
Denominator=((lambda1/epsil_1 + lambda2/epsil_2 + t_fe/epsil_fe + t_il1/epsil_il1 + t_il2/epsil_il2 + t_il3/epsil_il3 + t_il4/epsil_il4))

def func(Variables):
  VFE_Guess,Rho_s_Guess,PFE_Guess=Variables
  eq1=((Rho_s_Guess-PFE_Guess)*Parameter1)-VFE_Guess
  eq2=(((epsil_0*(va+V_bi))+PFE_Guess*Parameter2)/Denominator)-Rho_s_Guess
  eq3=p_s*np.tanh((VFE_Guess-sign1*V_c)*Parameter3)-PFE_Guess
  return [eq1,eq2,eq3]



def U_a(x):
    if -ts <= x <= 0 :
        return 0

    elif 0 <= x <= t_fe :
        return 1.5

    elif t_fe <= x <= t_fi1 :
        return 0.55

    elif t_fi1<= x <= t_fi2 :
        return 1.5

    elif t_fi2 <= x <= t_fi3 :
        return 0.55

    elif t_fi3 <= x <= t_fi4 :
        return 1.5

    elif t_fi4 <= x <= t_fi4 + td :
        return 0

    else:
        return 0

def U_fe(x, rho_s, p, v_a):

    if -ts <= x <= 0 :
        u_m1 = -1*(-(((rho_s*lambda1)/(epsil_0*epsil_1)) * np.exp(x/lambda1)) + v_a)
        return u_m1

    elif 0 <= x <= t_fe :
        u_fe = -1*(-(rho_s-p)*x/(epsil_0*epsil_fe) - (rho_s*lambda1)/(epsil_0*epsil_1) + v_a)
        return u_fe

    elif t_fe <= x <= t_fi1 :
        u_il1 = -1*(-rho_s*(x-t_fe)/(epsil_0*epsil_il1) - (rho_s-p)*t_fe/(epsil_0*epsil_fe) - (rho_s*lambda1)/(epsil_0*epsil_1) + v_a)
        return u_il1

    elif t_fi1 <= x <= t_fi2 :
        u_il2 = -1*(-rho_s*(x-t_fi1)/(epsil_0*epsil_il2) - (rho_s*t_il1)/(epsil_0*epsil_il1) - (rho_s-p)*t_fe/(epsil_0*epsil_fe) - (rho_s*lambda1)/(epsil_0*epsil_1) + v_a)
        return u_il2

    elif t_fi2 <= x <= t_fi3 :
        u_il3 =-1*( -rho_s*(x-t_fi2)/(epsil_0*epsil_il3) - (rho_s*t_il2)/(epsil_0*epsil_il2) - (rho_s*t_il1)/(epsil_0*epsil_il1)
                - (rho_s-p)*t_fe/(epsil_0*epsil_fe) - ((rho_s*lambda1)/(epsil_0*epsil_1)) + v_a)
        return u_il3

    elif t_fi3 <= x <= t_fi4 :
        u_il4 = -1*( -rho_s*(x-t_fi3)/(epsil_0*epsil_il4) - (rho_s*t_il3)/(epsil_0*epsil_il3) - (rho_s*t_il2)/(epsil_0*epsil_il2)
                - (rho_s*t_il1)/(epsil_0*epsil_il1) - (rho_s-p)*t_fe/(epsil_0*epsil_fe) - ((rho_s*lambda1)/(epsil_0*epsil_1)) + v_a)
        return u_il4

    elif t_fi4  <= x <= t_fi4 + td :
        u_m2 = -1*((rho_s*lambda2/(epsil_0*epsil_2)) * np.exp(-(x - t_fi4) / lambda2) -0)
        return u_m2

    else:
        return 0



# Define a range of x values
x_values = np.linspace(-2e-9, 2.5*t_fe, 10000)

# Compute U(x) for each x
U_a_values = np.array([U_a(x) for x in x_values])
# Plot the function
plt.plot(x_values, U_a_values)
plt.grid(True)
plt.show()
'''
U_fe_values = np.array([U_fe(x, rho_s,p,v_a) for x in x_values])

#plt.title('Potential barrier Profile')
plt.plot(x_values, U_fe_values, color="purple", lw=1, ls='-', marker='s', markersize=1, markerfacecolor="yellow", markeredgewidth=1, markeredgecolor="red")
plt.ylim(min(U_fe_values) - 1, max(U_fe_values) + 1)
plt.show()

U = U_a_values + U_fe_values
plt.plot(x_values, U, color="purple", lw=1, ls='-', marker='s', markersize=1, markerfacecolor="yellow", markeredgewidth=1,
         markeredgecolor="green")
# plt.xlim(-2e-9, 4e-9)
plt.ylim(min(U) - 0.1, max(U) + 0.1)
plt.show()
'''

# The following code calculates the value of PFE,VFE, RHo_s as a function of applied voltage in self-consistent manner
# We also evalued modified energy barrier
tolerance=1e-6
Vfe1,Rho_s1,Pfe1=1,1,0.13
initial_guess=[Vfe1,Rho_s1,Pfe1]
sign1=+1
V_max=5
N_points=2000
V_min1, V_max1 = -V_max,V_max
V_up=np.linspace(V_min1,V_max1,N_points)
V_down=np.linspace(V_max1,V_min1,N_points)
V_in=np.concatenate((V_up,V_down))
period_up = len(V_up)
period_down = len(V_down)
Va_plot_up=V_up
Va_plot_down=V_down
#Va_plot=np.concatenate((Va_plot_up,Va_plot_down))
#print('Va_plot',Va_plot)
#period=period_up+period_down
#print('Period',period
#step=np.zeros(2*N_points)
#V_in=np.concatenate((V_in,step))
#n_points=N_points*0.001
#for i in range(2*N_points):
 # if i<n_points:
  #  V_in[i]=V_max
  #else:
   # V_in[i]=0
#print('The External Voltage',V_in)
#sign1=-1
VFE_Full=[]
Rho_s_Full=[]
PFE_Full=[]
VFE_Pos_Cycle=np.zeros(N_points)
Rho_s_Pos_Cycle=np.zeros(N_points)
PFE_Pos_Cycle=np.zeros(N_points)

VFE_Neg_Cycle=np.zeros(N_points)
Rho_s_Neg_Cycle=np.zeros(N_points)
PFE_Neg_Cycle=np.zeros(N_points)
#counter=0;
for i in range(2*N_points):
  #va=V_in[i]
  #print('step',i)
  initial_guess=[Vfe1,Rho_s1,Pfe1]
  if i<N_points:
    sign1=+1
    #va=V_in[i]
    #print('Step',i)
    va=V_in[i]
    #counter=counter+1
    #sign1=+1
    initial_guess=[Vfe1,Rho_s1,Pfe1]
    Solution=fsolve(func,initial_guess,xtol=tolerance)
    #print('Initial_guess in positive cycle',initial_guess)
    Vfe1,Rho_s1,Pfe1=Solution
    VFE_Pos_Cycle[i]=Vfe1
    Rho_s_Pos_Cycle[i]=Rho_s1
    PFE_Pos_Cycle[i]=Pfe1
  else:
    #print('Step',i)
    sign1=-1
    #print('step',i)
    #print(sign1)
    va=V_in[i]
    initial_guess=[Vfe1,Rho_s1,Pfe1]
    #print('Applied_Voltage',va)
    Solution=fsolve(func,initial_guess,xtol=tolerance)
    #print('Initial_guess in negative cycle',initial_guess)
    Vfe1,Rho_s1,Pfe1=Solution
    VFE_Neg_Cycle[i-N_points]=Vfe1
    Rho_s_Neg_Cycle[i-N_points]=Rho_s1
    PFE_Neg_Cycle[i-N_points]=Pfe1
    #print('Vfe',Vfe1)
    #VFE_Full.append(Vfe1)
    #Rho_s_Full.append(Rho_s1)
     #PFE_Full.append(Pfe1)
U_fe_values = np.array([U_fe(x, Rho_s1,Pfe1,va) for x in x_values])
#plt.title('Potential barrier Profile')
plt.plot(x_values, U_fe_values, color="purple", lw=1, ls='-', marker='s', markersize=1, markerfacecolor="yellow", markeredgewidth=1, markeredgecolor="blue")
plt.ylim(min(U_fe_values) - 1, max(U_fe_values) + 1)
plt.show()

U = U_a_values + U_fe_values
plt.plot(x_values, U, color="blue", lw=1, ls='-', marker='s', markersize=1, markerfacecolor="yellow", markeredgewidth=1,
         markeredgecolor="magenta")
# plt.xlim(-2e-9, 4e-9)
plt.ylim(min(U) - 0.1, max(U) + 0.1)
plt.show()
#print('Counter',counter)
#step_counter=int(20*n_points)
VFE_Full=np.concatenate((VFE_Pos_Cycle,VFE_Neg_Cycle))
Rho_s_Full=np.concatenate((Rho_s_Pos_Cycle,Rho_s_Neg_Cycle))
PFE_Full=np.concatenate((PFE_Pos_Cycle,PFE_Neg_Cycle))
#print('VFE_Full',VFE_Full)
#plt.plot(V_in,PFE_Full,'-ro')

############################################
plt.figure(figsize=(6,5))
plt.plot(V_in, PFE_Full, '.', linewidth=1.0)
plt.xlabel('V_a (V)'); plt.ylabel('P_FE (C/m^2)')
plt.title('Hysteresis:PFE vs Va')
plt.grid(True); plt.tight_layout(); plt.show()
###################################################
#V_Fe_simu.remove(np.where(V_Fe_simu == min(V_Fe_simu)))
#del P_FE_simu[2000]
###########################################
plt.figure(figsize=(6,5))
plt.plot(VFE_Full, PFE_Full, '.', linewidth=1.0)
plt.xlabel('Vfe (V)'); plt.ylabel('P_FE (C/m^2)')
plt.title('Hysteresis:P_FE vs VFe, Va_max=3.0 V')
plt.grid(True); plt.tight_layout(); plt.show()
###############################################
plt.figure(figsize=(6,5))
plt.plot(V_up, PFE_Pos_Cycle, '.r', linewidth=1.0)
plt.plot(V_down, PFE_Neg_Cycle, '.b', linewidth=1.0)
plt.xlabel('V_a (V)'); plt.ylabel('PFE')
plt.title('Va vs PFE, Va_max=3.0 V')
plt.grid(True); plt.tight_layout(); plt.show()

# ======================================================================
# ALL ENERGY BARRIERS FOR 40 VOLTAGES
# ======================================================================
Va_21 = np.linspace(V_min1, V_max1, 40)
x_vals = np.linspace(-ts, t_fi4 + td, 2000)

plt.figure(figsize=(8,6))
ax = plt.gca()

for Vt in Va_21:
    # nearest hysteresis point
    idx = np.argmin(np.abs(Va_plot_up - Vt))

    P_fe = PFE_Pos_Cycle[-period_up:][idx]
    rho_s =Rho_s_Pos_Cycle[-period_up:][idx]

    Ua = np.array([U_a(x) for x in x_vals])
    Ufe = np.array([U_fe(x, rho_s, P_fe, Vt) for x in x_vals])
    Utot = Ua + Ufe

    col = plt.cm.rainbow((Vt - V_min1)/(V_max - V_min1))
    ax.plot(x_vals*1e9, Utot, color=col, alpha=0.55)

sm = plt.cm.ScalarMappable(cmap="rainbow", norm=plt.Normalize(V_min1, V_max1))
sm.set_array([])
plt.colorbar(sm, ax=ax, label="Voltage (V)")

plt.xlabel("x (nm)")
plt.ylabel("Energy (eV)")
plt.grid()
plt.tight_layout()
plt.show()

# ======================================================================
# ALL ENERGY BARRIERS FOR 40 VOLTAGES
# ======================================================================
Va_21 = np.linspace(V_max1, V_min1, 40)
x_vals = np.linspace(-ts, t_fi4 + td, 2000)

plt.figure(figsize=(8,6))
ax = plt.gca()

for Vt in Va_21:
    # nearest hysteresis point
    idx = np.argmin(np.abs(Va_plot_down - Vt))

    P_fe = PFE_Neg_Cycle[-period_down:][idx]
    rho_s =Rho_s_Neg_Cycle[-period_down:][idx]

    Ua = np.array([U_a(x) for x in x_vals])
    Ufe = np.array([U_fe(x, rho_s, P_fe, Vt) for x in x_vals])
    Utot = Ua + Ufe

    col = plt.cm.rainbow((Vt - V_min1)/(V_max - V_min1))
    ax.plot(x_vals*1e9, Utot, color=col, alpha=0.55)

sm = plt.cm.ScalarMappable(cmap="rainbow", norm=plt.Normalize(V_min1, V_max1))
sm.set_array([])
plt.colorbar(sm, ax=ax, label="Voltage (V)")

plt.xlabel("x (nm)")
plt.ylabel("Energy (eV)")
plt.grid()
plt.tight_layout()
plt.show()

